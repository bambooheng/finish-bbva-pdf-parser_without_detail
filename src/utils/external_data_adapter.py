"""外部流水明细数据适配器

此模块负责将外部流水明细数据直接集成到输出JSON中。
外部数据格式保持原样，不做额外转换。
"""
from typing import Any, Dict, Optional


def inject_external_transactions_to_output(
    output_data: Dict[str, Any],
    external_data: Dict[str, Any]
) -> Dict[str, Any]:
    """
    将外部流水明细数据注入到输出JSON中。
    
    直接使用外部数据格式，不做任何转换或增加额外信息。
    
    Args:
        output_data: 当前输出的JSON数据（包含metadata等）
        external_data: 外部流水明细数据
        
    Returns:
        合并后的完整JSON数据
    """
    # 直接将外部数据的pages结构添加到输出
    # 保持外部数据的原始格式和字段名称
    if "structured_data" not in output_data:
        output_data["structured_data"] = {}
    
    if "account_summary" not in output_data["structured_data"]:
        output_data["structured_data"]["account_summary"] = {}
    
    # 使用外部数据，保持其原始结构
    # 外部数据格式：
    # {
    #   "source_file": "...",
    #   "document_type": "B",
    #   "total_pages": 1,
    #   "total_rows": 35,
    #   "sessions": 1,
    #   "pages": [...]
    # }
    
    # Remove the 'transactions' list (generated by internal parser) to strictly follow external data format if present
    if "transactions" in output_data["structured_data"]["account_summary"]:
        del output_data["structured_data"]["account_summary"]["transactions"]

    # Re-order fields: transaction_details -> total_movimientos -> apartados_vigentes
    # Provide correct order by popping and re-inserting
    summary = output_data["structured_data"]["account_summary"]
    
    # Pop existing footer fields if they exist
    total_movimientos = summary.pop("total_movimientos", None)
    apartados_vigentes = summary.pop("apartados_vigentes", None)
    cuadro_resumen = summary.pop("cuadro_resumen", None)
    
    # Insert transaction_details (will be appended at current end)
    summary["transaction_details"] = {
        "source_file": external_data.get("source_file", ""),
        "document_type": external_data.get("document_type", ""),
        "total_pages": external_data.get("total_pages", 0),
        "total_rows": external_data.get("total_rows", 0),
        "sessions": external_data.get("sessions", 0),
        "pages": external_data.get("pages", [])
    }
    
    # Re-insert footer fields (will be appended after transaction_details)
    if total_movimientos:
        summary["total_movimientos"] = total_movimientos
    if apartados_vigentes:
        summary["apartados_vigentes"] = apartados_vigentes
        
    # Re-insert Cuadro Resumen at the VERY END (per user request)
    if cuadro_resumen:
        summary["cuadro_resumen"] = cuadro_resumen
    
    return output_data


def validate_external_transaction_format(external_data: Dict[str, Any]) -> bool:
    """
    验证外部流水明细数据格式是否正确。
    
    Args:
        external_data: 外部流水明细数据
        
    Returns:
        True if valid, False otherwise
    """
    required_fields = ["pages"]
    
    for field in required_fields:
        if field not in external_data:
            print(f"Warning: Missing required field '{field}' in external transaction data")
            return False
    
    # 验证pages结构
    pages = external_data.get("pages", [])
    if not isinstance(pages, list):
        print("Warning: 'pages' should be a list")
        return False
    
    for page in pages:
        if "rows" not in page:
            print(f"Warning: Missing 'rows' in page data")
            return False
    
    return True
def filter_transactions_by_period(
    external_data: Dict[str, Any],
    metadata: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Filter external transactions to include only those falling within the document's period.
    Used for multi-statement PDFs where we split extraction but have a single external transaction file.
    
    Args:
        external_data: Full external transaction data
        metadata: Extracted metadata from the current sub-document (containing period info)
        
    Returns:
        Filtered external transaction data structure
    """
    import copy
    from datetime import datetime
    
    # Clone to avoid mutating original
    filtered_data = copy.deepcopy(external_data)
    
    # Extract period from metadata
    period_start = metadata.get("period_start")
    period_end = metadata.get("period_end")
    
    if not period_start or not period_end:
        print("Warning: No period found in metadata, including ALL transactions")
        return filtered_data
        
    print(f"Filtering transactions for period: {period_start} to {period_end}")
    
    # Helper to parse dates
    def parse_date(date_obj):
        if isinstance(date_obj, str):
            # Try ISO format YYYY-MM-DD
            try:
                return datetime.strptime(date_obj, "%Y-%m-%d").date()
            except ValueError:
                return None
        return date_obj # Assume it's already a date object if not string? Or risky.
        
    start_dt = parse_date(period_start)
    end_dt = parse_date(period_end)
    
    if not start_dt or not end_dt:
        print("Warning: Could not parse period dates, including ALL transactions")
        return filtered_data

    # Filter Logic
    # External data structure: pages -> rows -> fecha_oper (DD/MMM) or fecha_oper_complete (YYYY-MM-DD)
    total_included = 0
    total_excluded = 0
    
    filtered_pages = []
    
    # Helper to parse fecha_oper like "05/JUN" to full date using period year
    def parse_partial_date(fecha_oper_str, period_year_start, period_year_end):
        """Parse DD/MMM format to full date using period context."""
        if not fecha_oper_str:
            return None
        
        # Month name mapping (Spanish)
        month_map = {
            'ENE': 1, 'FEB': 2, 'MAR': 3, 'ABR': 4, 'MAY': 5, 'JUN': 6,
            'JUL': 7, 'AGO': 8, 'SEP': 9, 'OCT': 10, 'NOV': 11, 'DIC': 12
        }
        
        # Parse DD/MMM format
        parts = fecha_oper_str.split('/')
        if len(parts) != 2:
            return None
        
        try:
            day = int(parts[0])
            month_abbr = parts[1].upper()
            month = month_map.get(month_abbr)
            
            if not month:
                return None
            
            # Determine year: if month >= start_month, use start year; else use end year
            start_month = start_dt.month
            
            if month >= start_month:
                year = period_year_start
            else:
                year = period_year_end
            
            from datetime import datetime
            return datetime(year, month, day).date()
        except (ValueError, AttributeError):
            return None
    
    period_year_start = start_dt.year if start_dt else None
    period_year_end = end_dt.year if end_dt else None
    
    for page in filtered_data.get("pages", []):
        new_rows = []
        for row in page.get("rows", []):
            # Try fecha_oper_complete first (full ISO date)
            fecha_oper_str = row.get("fecha_oper_complete", "")
            
            txn_date = None
            if fecha_oper_str:
                txn_date = parse_date(fecha_oper_str)
            
            # Fallback: use fecha_oper (DD/MMM) with period year context
            if not txn_date and period_year_start and period_year_end:
                fecha_oper_partial = row.get("fecha_oper", "")
                if fecha_oper_partial:
                    txn_date = parse_partial_date(fecha_oper_partial, period_year_start, period_year_end)
            
            if txn_date:
                if start_dt <= txn_date <= end_dt:
                    new_rows.append(row)
                    total_included += 1
                else:
                    total_excluded += 1
            else:
                # If no date found, exclude it (safer than including)
                total_excluded += 1
        
        # Only keep page if it has relevant rows
        if new_rows:
            page["rows"] = new_rows
            filtered_pages.append(page)
            
    filtered_data["pages"] = filtered_pages
    filtered_data["total_rows"] = total_included
    
    print(f"Transaction Filtering: Included {total_included}, Excluded {total_excluded}")
    return filtered_data
